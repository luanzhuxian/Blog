---
title: ES2019
comments: true
abbrlink: 46ad9c0
date: 2019-08-15 16:26:34
categories: [javascript, es6]
tags: [javascript, es6]
---

# Array.flat(depth)
递归平铺多维数组，`depth`指定嵌套数组中的结构深度，也就是指定的递归层级，默认是 1。此方法并不修改原数组，而是返回一个新的数组。  

之前如果我们想平铺数组可以这样做：
```
    const flatten = arr => arr.reduce((flat, next) => flat.concat(Array.isArray(next) ? flatten(next) : next), [])
```
或者利用展开运算符，但只适用于二维数组，不过可以通过递归平铺任意维度的数组：
```
    function flattenArray(arr) {
        const flattened = [].concat(...arr)
        return flattened.some(item => Array.isArray(item))
        ? flattenArray(flattened) 
        : flattened
    }
    const arr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]]
    const flatArr = flattenArray(arr) // => [11, 22, 33, 44, 55, 66, 77, 88, 99]
```
现在我们可以直接使用：
```
    const arr1 = [1, 2, [3, 4]]
    arr1.flat() // [1, 2, 3, 4]
    const arr2 = [1, 2, [3, 4, [5, 6]]]

    arr2.flat(2) // [1, 2, 3, 4, 5, 6]
    const arr3 = [1, 2, [3, 4, [5, 6, [7, 8]]]]

    arr3.flat(Infinity) // [1, 2, 3, 4, 5, 6, 7, 8]
```
如果数组中有空值，则会在平铺后移除：
```
    const arr4 = [1, 2, , 4, 5]
    arr4.flat() // [1, 2, 4, 5]
```

# Array.flatMap()
A new method that combines the basic map function and then flattens the result to a depth of 1 with the new Array.flat() method:
```
    const arr1 = [1, 2, 3]

    arr1.map(x => [x * 4]) // [[4], [8], [12]]
    arr1.flatMap(x => [x * 4]) // [4, 8, 12]
```
Another more useful example:
```
    const sentence = ["This is a", "regular", "sentence"]

    sentence.map(x => x.split(" ")) // [["This","is","a"],["regular"],["sentence"]]
    sentence.flatMap(x => x.split(" ")) // ["This","is","a","regular", "sentence"]
```

# String.trimStart() and String.trimEnd()
In addition to String.Trim() which removes whitespaces from both sides of a string there are now separate methods for only removing white spaces from each side:
```
    const test = "hello"

    test.trim() // "hello"
    test.trimStart() // "hello "
    test.trimEnd() // " hello"
```

# Object.fromEntries
A new method that transforms a list of key-value pairs into an object. It performs the reverse of an already familiar function Object.Entries which is used when transforming objects to arrays for their easier manipulation. After the transformation, you would be left with an array but now you can return the manipulated array back into an object. Let’s try with an example where we want to square the values of all of our object properties:
```
    const obj = { prop1: 2, prop2: 10, prop3: 15 }                                   
    let array = Object.entries(obj) // [["prop1", 2], ["prop2", 10], ["prop3", 15]]
    array = array.map(([key, value]) => [key, Math.pow(value, 2)]) // [["prop1", 4], ["prop2", 100], ["prop3", 225]]
    const newObj = Object.fromEntries(array) // {prop1: 4, prop2: 100, prop3: 225}
```

# Optional Catch Binding
The new proposal allows you to completely omit the catch() parameter as there are a lot of cases where you don’t want to use it:
```
    try {
        //...
    } catch (er) {
        //handle error with parameter er
    }

    try {
        //...
    } catch {
        //handle error without parameter
    }
```

# Symbol.description
You can now access the description property of a Symbol instead of using the toString() method:
```
    const testSymbol = Symbol("Desc")

    testSymbol.description // "Desc"
```

# Function.toString()
Calling toString() on a function now returns the function exactly as it was defined including whitespaces and comments. Before we had:
```
    function /* foo comment */ foo() {}

    foo.toString() // "function foo() {}"
```
And now it’s:
```
    foo.toString(); // "function /* foo comment */ foo() {}"
```